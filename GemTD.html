<!doctype html>
<html>
<head>
<script src="./jquery-2.1.4.min.js"></script>
</head>
<body>
<div id="gameArea"></div>

<script>

var noGoColor="black";
var pathColor="grey";
var defaultColor="white";

var testGit="hi";

var Monster = function (left,top) {
	var position = "absolute";
}

var LineSegment = function (ix1,iy1,ix2,iy2) {
	var x1=ix1;
	var y1=iy1;
	var x2=ix2;
	var y2=iy2;
	this.isPointOnLine = function (x,y) {
		if ( (x>= ix1 && x<= ix2 && y>=iy1 && y <=iy2)
		|| (x>= ix2 && x<= ix1 && y>=iy2 && y <=iy1)
		)
		return true;
	}
}

function pickMinArray(a,b,c,d) {
alert(a + " - " + b + " - " + c + " - " + d);
if (a.length<=b.length && a.length<=c.length && a.length<=d.length)
return a;
if (b.length<=a.length && b.length<=c.length && b.length<=d.length)
return b;
if (c.length<=a.length && c.length<=b.length && c.length<=d.length)
return c;
if (d.length<=a.length && d.length<=b.length && d.length<=c.length)
return d;

}


//[0,0],[0,1],[0,2],[0,3],[1,3],[2,3],[3,3]
beenTo=[];
function haveBeenTo(dx,dy,path) {
//alert(dx + " -- " + dy + " -- " + path + " -- " + beenTo);
	for (x=0;x<beenTo.length;x++) {
		if ((beenTo[x][0]==dx+1 && beenTo[x][1]==dy && path==1) ||
			(beenTo[x][0]==dx && beenTo[x][1]==dy+1 && path==2) ||
			(beenTo[x][0]==dx-1 && beenTo[x][1]==dy && path==3) ||
			(beenTo[x][0]==dx && beenTo[x][1]==dy-1 && path==4)) {
				//alert('wut');
	//			alert('TRUE: ' + dx + " -- " + dy + " -- " + path + " -- " + beenTo);

				return true;
				
			}
	}
	return false;
}

function removePathDuplicates(iArray) { // input Array
	var newArray = [];
	var removed= [];
	var remove = false;
	for (var x=0;x<iArray.length;x++) {
		remove = true;
		for (var y=0;y<iArray.length;y++) {
			if (iArray[x][0]==iArray[y][0] && iArray[x][1] == iArray[y][1] && x!=y) {
				remove = true;
				
				logT(x+ "," + y + " : " + iArray[x][0] + " == " + iArray[y][0] + " AND " + iArray[x][1] + " == " + iArray[y][1] + " REMOVE? " + remove);
				break;
			} else
				remove = false;
		}
		//if (remove == false) {
			logT(iArray[x]);
			newArray.push(iArray[x]);
	//	} else removed.push(iArray[x]);
	}
	
	return newArray;

}

function logT(l) {
	var e = document.createElement("span");
	e.appendChild(document.createTextNode(l));
	
	document.getElementById("LOG").appendChild(document.createElement("br"));
	document.getElementById("LOG").appendChild(e);

	//document.createElement("<span><br>" + l + "</span>");
}

function getMiddleNumber(x,y) {
	if (x>y)
		return Math.round(((x-y)/2)+y);
	else
		return Math.round(((y-x)/2)+x);
}

function findPathBetweenPoints(sx,sy,dx,dy) {
	// weigh the path in the right direction...
	// Get the difference between all 4 scenarios whichever gets closer faster
	// 1 - x+1, 2 - y+1, 3 - x-1, 4 - y-1
	beenTo.push([sx,sy]);
	logT(sx + "," + sy + "," + dx + "," + dy);
	xDir = "SAME";
	yDir = "SAME";
	if (dx - sx > 0 )  // Then were going 'right'
		xDir = "RIGHT";
	if (sx - dx > 0 )
		xDir = "LEFT";
	
	if (dy-sy>0) // Then were going 'Right'
		yDir = "DOWN";
	if (sy-dy>0)
		yDir = "UP";
	
	var newsXA=0;
	var newdXA=0;
	var newsXB=0;
	var newdXB=0;
	var newsYA=0;
	var newdYA=0;
	var newsYB=0;
	var newdYB=0;
	var diffXAReal=0;
	
	if (xDir=="LEFT") {
		newsXA=getMiddleNumber(sx,dx);
		newdXA=dx;
		
		newsXB=sx;
		newdXB=getMiddleNumber(sx,dx);

	}
	
	if (yDir=="DOWN") {
		newsYA=getMiddleNumber(sy,dy);
		newdYA=dy;
		
		newsYB=sy;
		newdYB=getMiddleNumber(sy,dy);
	}

	if (yDir=="UP") {
		newsYA=dy;
		newdYA=getMiddleNumber(sy,dy);
		
		newsYB=getMiddleNumber(sy,dy);		
		newdYB=sy;
	}

	if (xDir=="RIGHT") {
		newsXA=dx;
		newdXA=getMiddleNumber(sx,dx);
		
		newsXB=getMiddleNumber(sx,dx);
		newdXB=sx;
	}
	
	if (xDir == "SAME") {
		newsXA=sx;
		newdXA=dx;
		newsXB=sx;
		newdXB=dx;
	}  

	if (yDir == "SAME") {
		newsYA=sy;
		newdYA=dy;
		newsYB=sy;
		newdYB=dy;
	}
	
	logT(xDir + " - " + yDir + " == " + newsXA + 
		" - " + newsYA + " - " + newdXA + " - " + newdYA + " : " + newsXB + " - " + newsYB + " - " + newdXB + " - " + newdYB + " : ");

	var diffXAReal=newdXA-newsXA;
	var diffXBReal=newdXB-newsXB;
	var diffYAReal=newdYA-newsYA;
	var diffYBReal=newdYB-newsYB;
	
	var diffXA=Math.abs(diffXAReal);
	var diffYA=Math.abs(diffYAReal);
	var diffXB=Math.abs(diffXBReal);
	var diffYB=Math.abs(diffYBReal);
	
	var diffx=Math.abs(dx-sx);
	var diffy=Math.abs(dy-sy);
	
	logT("diffXA:" + diffXAReal + " , " + diffYAReal + " , " + diffXBReal + " , " + diffYBReal + " : " + diffx + " , " + diffy)
	if (	(diffXA==1 && diffYA==0 && diffy<2) || 
			(diffXA==0 && diffYA==1 && diffx<2) // 0 1 0
		)
	{
		var toReturn;
		if (diffy==3)
			var toReturn = [[sx,sy],[sx+diffXAReal,sy+diffYAReal],[sx+diffXAReal,sy+diffYAReal+diffYAReal],[newdXA,newdYA]];
		else
			var toReturn = [[sx,sy],[sx+diffXAReal,sy+diffYAReal],[newdXA,newdYA]];
		logT("Returning A1: " + toReturn  );
		return toReturn;
	}

	if (	(diffXB==1 && diffYB==0 && diffy<2) || 
			(diffXB==0 && diffYB==1 && diffx<2)  
		) {
		var toReturn;
		if (diffy==3)
			var toReturn = [[sx,sy],[sx+diffXBReal,sy+diffYBReal],[sx+diffXBReal,sy+diffYBReal+diffYBReal],[newdXB,newdYB]];
			//var toReturn = [[sx,sy],[sx+diffXAReal,sy+diffYAReal],[sx+diffXAReal,sy+diffYAReal+diffYAReal],[newdXA,newdYA]];
		else
			var toReturn = [[sx,sy],[sx+diffXBReal,sy+diffYBReal],[newdXB,newdYB]];
			
		//var toReturn = [[sx,sy],[[newsXB,newsYB],[newdXB,newdYB]];
		logT("Returning B1: " + toReturn);
		return toReturn;
	}
	
	if ( (diffXA==1 && diffYA==1 && (diffx<2 || diffy<2)) ) // Both one away, causes infinite loop if I don't do this!
	{
		var path = Math.round(Math.random()*(2-1)+1); // Randomly go one way or the other
		if (path==1) {
			var toReturn = [[sx,sy],[sx,sy+diffYAReal],[sx+diffXAReal,sy+diffYAReal]]; //,[newdXA,newsYA],[newdXA,newdYA]];
			logT("ReturningA2.1: " + toReturn);
			return toReturn; // Keep Y the same then keep X the same
		} else {
			var toReturn = [[sx,sy],[sx+diffXAReal,sy],[sx+diffXAReal,sy+diffYAReal]]; //,[newsXA,newdYA],[newdXA,newdYA]]
			logT("ReturningA2.2: " + toReturn);
			return toReturn; // Keep X the same then keep Y the same
		}
	}
	
	if ( (diffXB==1 && diffYB==1 && (diffx<2 || diffy<2)) ) // Both one away, causes infinite loop if I don't do this!
	{
		var path = Math.round(Math.random()*(2-1)+1); // Randomly go one way or the other
		if (path==1) {
			var toReturn = [[sx,sy],[sx,sy+diffYBReal],[sx+diffXBReal,sy+diffYBReal]]; //,[newdXB,newsYB],[newdXB,newdYB]];
			logT("ReturningB2.1: " + toReturn);

			return toReturn; // Keep Y the same then keep X the same
		} else {
			var toReturn = [[sx,sy],[sx+diffXBReal,sy],[sx+diffXBReal,sy+diffYBReal]]; //,[newsXB,newdYB],[newdXB,newdYB]];
			logT("ReturningB2.2: " + toReturn );
			return toReturn; // Keep X the same then keep Y the same
		}
	
	}
	
	if (xDir == "SAME" && yDir == "SAME") {
		logT("MADE SAME");
		return [];
	}
	
	var aOUT=findPathBetweenPoints(newsXB,newsYB,newdXB,newdYB);
	var bOUT=findPathBetweenPoints(newsXA,newsYA,newdXA,newdYA);

	logT("A:" +aOUT + " B:" + bOUT);
	aOUT.pop(); // Since our middle number should be in both arrays, drop the last record in the first array so we don't double count
	return aOUT.concat(bOUT);

}


var isThisInPath = function (x,y) {
// Just reference at this point, couldn't
//	this.pathList = [[4,4],[4,20],[32,20],[32,5],[19,5],[19,32],[32,32]];

		if (new LineSegment(4,4,4,20).isPointOnLine(x,y)) // Start to p1
			return true;
		if (new LineSegment(4,20,32,20).isPointOnLine(x,y)) // p1 to p2
			return true;
		if (new LineSegment(32,20,32,5).isPointOnLine(x,y)) // p2 to p3
			return true;
		if (new LineSegment(32,5,19,5).isPointOnLine(x,y)) // p3 to p4
			return true;
		if (new LineSegment(19,5,19,32).isPointOnLine(x,y)) // p4 to p5
			return true;
		if (new LineSegment(19,32,32,32).isPointOnLine(x,y)) // p4 to exit
			return true;
}

var isThisBlocked = function (id) {
// Just reference at this point, couldn't
//	this.pathList = [[4,4],[4,20],[32,20],[32,5],[19,5],[19,32],[32,32]];

y=id.split("y")[1];
x=id.split("y")[0].split("x")[1];

		
		if (new LineSegment(0,0,8,5).isPointOnLine(x,y)) // Around entrance
			return true;
		if (new LineSegment(4,20,4,20).isPointOnLine(x,y)) // p1
			return true;
		if (new LineSegment(32,20,32,20).isPointOnLine(x,y)) // p2
			return true;
		if (new LineSegment(32,5,32,5).isPointOnLine(x,y)) // p3
			return true;
		if (new LineSegment(19,5,19,5).isPointOnLine(x,y)) // p4
			return true;
		if (new LineSegment(19,32,19,32).isPointOnLine(x,y)) // p5
			return true;
		if (new LineSegment(32,30,34,34).isPointOnLine(x,y)) // Around exit
			return true;
		return hasGem([x,y]);
}

var Board = function () {
	var position = "absolute";
	var left = "50px";
	var top = "50px";
	var width = 37;
	var height = 37;
	var squareSize = 20;
	var squareList=null;
	var monsterList = new Array();
	
	this.writeBoard = function (i,n) {
		var b = document.createElement("div");
		b.id=n;
		b.style.position = position;
		b.style.left = left;
		b.style.top = top;
		b.style.background = "grey";
		b.style.width=width*squareSize+"px";
		b.style.height=height*squareSize+"px";
		document.getElementById(i).appendChild(b);
	}
	
	this.getPxAtPoint = function(x,y) {
			var px = {
			left: x*(squareSize),
			top: y*(squareSize)
			}			
			return px;
		}

	
	this.addMonster = function () {
		point = this.getPxAtPoint(4,4);
		var m = document.createElement("span");
		m.id = "mob1";
		m.style.position="absolute";
		m.style.left = point.left+"px";
		m.style.top = point.top+"px";
		m.style.background = "red";
		//m.innerHTML="M";
		m.style.zIndex="1";
		m.style.width=squareSize+"px";
		m.style.height=squareSize+"px";
		monsterList.push(m);
		document.getElementById("board").appendChild(m);
	}
	
	this.moveMonster = function (xp,yp,path) {
		len = monsterList.length;
		for (x=0;x<len;x++) {
			point = this.getPxAtPoint(xp,yp);
			o = monsterList[x];
			$(o).animate({top: "+=" + (point.top-parseFloat(o.style.top,10)),left: "+=" + (point.left-parseFloat(o.style.left,10)) }, 100,"linear", function() {
				if (path.length>0) {
					p = path.pop();
					board.moveMonster(p[0],p[1],path)
				}
			})
		}
	}

	this.moveMonsterOnPath = function () {
		//try {
		newPathList=findPathBetweenPoints(20,4,2,32);
		newPathList=removePathDuplicates(newPathList);
		newPathList.reverse();

		/*} catch(e) {
			alert('Probably exceeded stack size, reload and try again! Running default path!');
			this.getPointsInPath();
		}*/
		output="newPathList:<BR>";
		for (x=0;x<newPathList.length;x++)
			output=output+newPathList[x] + " <BR>";
		//document.getElementById("DUMP").innerHTML=output;
		output=output + "<BR>BEENTO:<BR>";
		for (x=0;x<beenTo.length;x++)
			output=output+beenTo[x] + " <BR>";
		document.getElementById("DUMP").innerHTML=output;		
		//alert(newPathList);
		this.moveMonster(4,4,newPathList);
	}
	
	this.addSquares = function () {
// (4,4) => (4,20) => (32,20) => (32,5) => (19,5) => (19,32) => (32,32)
		for (x=0;x<width;x++)
		{
			for (y=0;y<height;y++)
			{
				tmpId= "x"+x+"y"+y;
				
				var gemSpace = document.createElement("span");
				gemSpace.id=tmpId;
				gemSpace.style.position="absolute";
				gemSpace.style.left=parseFloat(left,10)+x*squareSize+"px";
				gemSpace.style.top=parseFloat(top,10)+y*squareSize + "px";
				
				if (isThisInPath(x,y))
					gemSpace.style.background=pathColor;
				else
					gemSpace.style.background=defaultColor;
				if (isThisBlocked(tmpId))
					gemSpace.style.background=noGoColor;
				gemSpace.style.width=squareSize+"px";
				gemSpace.style.height=squareSize+"px";
				gemSpace.style.border="thin solid black";
				gemSpace.gem=null;
				gemSpace.onclick=function(s) { addGem(s); };
				document.getElementById("gameArea").appendChild(gemSpace);
		//		document.write("<span style='position:absolute;left:" + x*squarePostionVar + "px;top:" + y*squarePostionVar + "px;background:black;width:"+squareSize+"px;height:"+squareSize+"px'></span>");
			}
		}
	
	
	}
	
	
	var pathList = [[4,4],[4,20],[32,20],[32,5],[19,5],[19,32],[32,32]];
	var newPathList = [];

	this.getPointsInPath = function () {
	localPath = pathList.slice();
	localPath.reverse();

			firstPoint = localPath.pop();
			middlePoint = firstPoint;
		breakCount=0
		while (localPath.length >0) {

			secondPoint = localPath.pop();
			
			newPathList.push(middlePoint);

			while (middlePoint[0] != secondPoint[0] || middlePoint[1] != secondPoint[1]) {
				breakCount=breakCount++;
				if (breakCount>40*40) {
				alert('maze to big');
				break;
				}
				newMiddlePoint = [middlePoint[0],middlePoint[1]];

				if (newMiddlePoint[0]<secondPoint[0]) {
					if (!hasGem([newMiddlePoint[0]+1,newMiddlePoint[1]])) {
						newMiddlePoint[0]=newMiddlePoint[0]+1;
						newPathList.push([newMiddlePoint[0],newMiddlePoint[1]]);
						middlePoint=newMiddlePoint;
						continue;
					}
				}
				if (newMiddlePoint[0]>secondPoint[0]) {
					if (!hasGem([newMiddlePoint[0]-1,newMiddlePoint[1]])) {
						newMiddlePoint[0]=newMiddlePoint[0]-1;
						newPathList.push([newMiddlePoint[0],newMiddlePoint[1]]);
						middlePoint=newMiddlePoint;
						continue;
					}
				}
				if (newMiddlePoint[1]<secondPoint[1]) {
					if (!hasGem([newMiddlePoint[0],newMiddlePoint[1]+1])) {						
						newMiddlePoint[1]=newMiddlePoint[1]+1;
						newPathList.push([newMiddlePoint[0],newMiddlePoint[1]]);
						middlePoint=newMiddlePoint;
						continue;
					}
				}
				if (newMiddlePoint[1]>secondPoint[1]) {
					if (!hasGem([newMiddlePoint[0],newMiddlePoint[1]-1])) {
						newMiddlePoint[1]=newMiddlePoint[1]-1;
						newPathList.push([newMiddlePoint[0],newMiddlePoint[1]]);
						middlePoint=newMiddlePoint;
						continue;
					}
				}
				
				// Making it here means there was an obstical somewhere, custom move path required
				
				// 
				/*
				while (newMiddlePoint[0] >0 && newMiddlePoint[0] < 36 && newMiddlePoint[1] > 0 && newMiddlePoint[1] < 36 ) {
				n= newMiddlePoint;
					if (hasGem([n[0],n[1]+1])) {
						// check if we can go around it on the other side
						leftPlus=1;
						while (hasGem([n[0]-1,n[1]+leftPlus)) {
							leftPlus=leftPlus+1
						}
						if (!hasGem([n[0]-1,n[1]+1])) {
							newMiddlePoint[0]=newMiddlePoint[0]-1;
							newPathList.push([newMiddlePoint[0],newMiddlePoint[1]]);
							newMiddlePoint[1]=newMiddlePoint[1]+1;
							newPathList.push([newMiddlePoint[0],newMiddlePoint[1]]);
							middlePoint=newMiddlePoint;
							break;
						}
						if (!hasGem([n[0]+1,n[1]+1])) {
							newMiddlePoint[0]=newMiddlePoint[0]+1;
							newPathList.push([newMiddlePoint[0],newMiddlePoint[1]]);
							newMiddlePoint[1]=newMiddlePoint[1]+1;
							newPathList.push([newMiddlePoint[0],newMiddlePoint[1]]);
							middlePoint=newMiddlePoint;
							break;
						}
					}
				
				}
*/
				
				
			}
		}
		newPathList.reverse();
	}

	this.findPath = function () {
		var startingPoint = [4,3];
		var pathList = [[4,20],[32,20],[32,5],[19,5],[19,32],[32,32]];
		
	
	}
	
	
}

function hasGem(p) {
	try {
	if (document.getElementById("x"+p[0]+"y"+p[1]).gem != null) {
		return true;
	} else 
		return false;
	} catch(e) {
		return false;
	}
}

function Square() {
	this.size = 10;
	this.blocked = false;
	this.gem = null;
	this.monster = false;
	this.pixels = new Array(10);
	for (x=0;x<this.pixels.length;x++)
		this.pixels[x]=new Array(10);
}

/*
var gemList = new Array();
var hasteGems = new Array();
var gradeChipped = 80;
var gradeFlawed = 20;
var gradeRegular = 0;
var gradeNormal = 0;
var gradeFlawless = 0;
var gradePerfect = 0;

if (!Array.isArray(board.boardList))
	board.boardList= []
board.boardList.push(new Square())
board.writeBoard("x","n");

*/
function getGrade() {
	return 1; // default to chipped right now
}

function getGemType(t) {

	var gem = new Object();
	gem.gType=t;
	gem.grade=getGrade();
	gem.AOERange=0;
	gem.providesAura="false";
	gem.armorReduced=0;
	gem.range=200;
	
	switch(t) {
		case 1: // Base Haste Gem
			gem.providesAura="true";
			gem.damage=1;
			gem.speed=0.2;
			gem.range=200;
			gem.background="purple";
			break;
		case 2: // Base Armor reduction Gem
			gem.armorReduced=-1;
			gem.damage=3;
			gem.speed=0.4;
			gem.range=200;
			gem.background="orange";
		case 3: // Base AOE gem
			gem.AOERange=100;
			gem.damage=2;
			gem.speed=0.5;
			gem.range=200;
			gem.background="red";
			break;
		case 4: // Base Crit Gem
			gem.critChance=0.2;
			gem.critDamageMultiplier=1.5;
			gem.damage=4;
			gem.speed=0.3;
			gem.range=200;
			gem.background="brown";
			break;
		case 5: // Base slow gem
			gem.slowRate=0.1;
			gem.damage=3;
			gem.speed=0.3;
			gem.range=200;
			gem.background="blue"
			break;
		case 6: // Base fast gem
			gem.damage=2;
			gem.speed=0.1;
			gem.range=200;
			gem.background="pink";
			break;
		case 7: // Base DOT/poison gem
			gem.DOT=1;
			gem.DOTTime=5;
			gem.damage=1;
			gem.speed=0.5;
			gem.range=200;
			gem.background="green";
			break;
		default:
			break;
	}
	return gem;
}


function getGem()
{
	var gem = new Object();
	gem.type=Math.floor((Math.random()*7)+1);
	gem.gemObject = getGemType(gem.type);

return gem;
}

function addGem(s)
{
	if (s.target.gem == undefined && !isThisBlocked(s.target.id)) {
		var g = getGem();
		s.target.gem = g;
		s.target.style.background = g.gemObject.background;
	}
document.getElementById("INFO").innerHTML=s.target.id;
}


function createMonster() {

	

}

var board = null;

$(document).ready(function () {
board = new Board();
board.writeBoard("gameArea","board");
board.addSquares();
board.addMonster();

//setTimeout(function() { board.moveMonsterOnPath() },12000);
//setTimeout(function() { document.getElementById("INFO").innerHTML = 
//board.moveMonster();
//board.startGameLoop();
})








</script>
<span id="INFO"></span><input type="button" onclick="board.moveMonsterOnPath()" value="Start">
<div id="DUMP" style="position:absolute;left:850px;top:20px">DUMP</div>
<div id="LOG" style="position:absolute;left:950px;top:20px">LOG</div>
</body>
</html>